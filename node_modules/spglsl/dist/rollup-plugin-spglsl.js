"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rollupPluginSpglsl = void 0;
/* eslint-disable no-console */
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const spglsl_compile_1 = require("./spglsl-compile");
/**
 * A plugin for rollup and vite
 */
function rollupPluginSpglsl(options) {
    options = { ...options };
    if (options.minify === undefined && options.compileMode === "Optimize") {
        options.minify = true;
    }
    const extensionsSet = new Set(options.extensions || rollupPluginSpglsl.defaultExtensions);
    function finalizeSettings(isProduction) {
        options.isProduction = !!isProduction;
        if (!options.cwd) {
            options.cwd = process.cwd();
        }
        if (options.compileMode === undefined) {
            options.compileMode = isProduction ? "Optimize" : "Validate";
        }
        if (options.minify === undefined) {
            options.minify = isProduction && options.compileMode === "Optimize";
        }
    }
    // This hook get called with the final resolved vite config.
    const configResolved = ({ isProduction, command }) => {
        if (options.isServer === undefined) {
            options.isServer = command === "serve";
        }
        if (options.throwOnError === undefined) {
            options.throwOnError = !options.isServer;
        }
        if (isProduction !== undefined && options.isProduction === undefined) {
            finalizeSettings(isProduction);
        }
        if (options.logging === undefined) {
            options.logging = true;
        }
    };
    async function spglslTransform(code, id) {
        if (options.isProduction === undefined) {
            finalizeSettings(process.env.NODE_ENV === "production");
        }
        if (!extensionsSet.has(path_1.default.posix.extname(id))) {
            return undefined;
        }
        const spglslResult = (await (0, spglsl_compile_1.spglslAngleCompile)({
            ...options,
            mainFilePath: id,
            mainSourceCode: code,
        }));
        spglslResult.isServer = !!options.isServer;
        spglslResult.isProduction = !!options.isProduction;
        spglslResult.throwOnError = !!options.throwOnError;
        if (!spglslResult.output) {
            spglslResult.output = code;
        }
        if (options.onSpglslDone) {
            await options.onSpglslDone(spglslResult);
        }
        if (!spglslResult.valid) {
            if (spglslResult.throwOnError) {
                throw new spglsl_compile_1.SpglslAngleCompileError(spglslResult, options.isProduction
                    ? undefined
                    : `spglsl ${spglslResult.compileMode} ${id}:${spglslResult.infoLog.toString({
                        colors: false,
                    })}`);
            }
            else if (options.logging) {
                console.error(`\n${chalk_1.default.blue(`spglsl:${spglslResult.compileMode}`)} ${(0, spglsl_compile_1.inspectSpglslAngleCompileResult)(spglslResult)}`);
            }
        }
        else {
            if (options.logging) {
                console.info(`\n${chalk_1.default.blue(`spglsl:${spglslResult.compileMode}`)} ${(0, spglsl_compile_1.inspectSpglslAngleCompileResult)(spglslResult)}`);
            }
            if (options.isProduction) {
                const validateResult = await (0, spglsl_compile_1.spglslAngleCompile)({
                    ...options,
                    compileMode: "Validate",
                    minify: false,
                    mangle: false,
                    mangle_global_map: undefined,
                    mainSourceCode: spglslResult.output,
                    mainFilePath: id,
                });
                if (!validateResult.valid) {
                    throw new spglsl_compile_1.SpglslAngleCompileError(validateResult, "post validation failed");
                }
            }
        }
        if (spglslResult.mangle && spglslResult.mangle_global_map) {
            for (const type of ["uniforms", "globals"]) {
                for (const [key, value] of Object.entries(spglslResult[type])) {
                    if (key === value && !spglslResult.mangle_global_map[key] && value.length > 2) {
                        console.warn(chalk_1.default.yellow(`WARN: ${type.endsWith("s") ? type.slice(0, type.length - 1) : type} ${key} is not mangled`));
                    }
                }
            }
        }
        const r = JSON.stringify(spglslResult.compileMode === "Validate" ? spglslResult.source : spglslResult.output);
        let js;
        js = `export const code=${r};\n`;
        js += "export default code;\n";
        js += `\nexport const uniformNames = ${JSON.stringify(spglslResult.uniforms)};\n`;
        for (const [key, value] of Object.entries(spglslResult.uniforms)) {
            js += `export const uniformName_${key}=${JSON.stringify(value)};\n`;
        }
        js += `\nexport const globalNames = ${JSON.stringify(spglslResult.globals)};\n`;
        for (const [key, value] of Object.entries(spglslResult.globals)) {
            js += `export const globalName_${key}=${JSON.stringify(value)};\n`;
        }
        js += `\nexport const constDefs = ${JSON.stringify(spglslResult.constDefs)};\n`;
        for (const [key, value] of Object.entries(spglslResult.constDefs)) {
            js += `export const constDef_${key}=${JSON.stringify(value)};\n`;
        }
        return { code: js, map: null };
    }
    return {
        name: "spglsl",
        configResolved,
        transform: spglslTransform,
    };
}
exports.rollupPluginSpglsl = rollupPluginSpglsl;
rollupPluginSpglsl.defaultExtensions = [".frag", ".vert", ".comp"];
//# sourceMappingURL=rollup-plugin-spglsl.js.map