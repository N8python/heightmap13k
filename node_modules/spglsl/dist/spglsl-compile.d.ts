import type { GlslInfoLogArray } from "./glsl-info-log";
import type { SpglslLanguage, SpglslCompileMode } from "./spglsl-enums";
import type { SpglslResourceLimits } from "./spglsl-resource-limits";
export interface SpglslAngleCompileOptions {
    compileMode?: SpglslCompileMode;
    language?: string;
    customData?: unknown;
    resourceLimits?: Partial<SpglslResourceLimits>;
    minify?: boolean;
    /** If true, mangle all variables and functions, except uniforms and the function that starts with "main" */
    mangle?: boolean;
    /** If not undefined, and mangle is true, this field will be used to mange uniforms and shared between compilation steps. */
    mangle_global_map?: Record<string, string> | undefined;
    beautify?: boolean;
    recordConstantPrecision?: boolean;
}
export interface SpglslAngleCompileInput extends SpglslAngleCompileOptions {
    mainFilePath?: string;
    mainSourceCode: string;
    cwd?: string;
}
export declare class SpglslAngleCompileResult {
    compileMode: SpglslCompileMode;
    mainFilePath: string;
    language: SpglslLanguage;
    outputVersion: number;
    valid: boolean;
    customData: unknown | undefined;
    /** The time it took to compile, in milliseconds */
    duration: number;
    /** The source code input */
    source: string;
    /** The output or null if there is no output */
    output: string | null;
    /** The map of uniform names defined in the shader */
    uniforms: Record<string, string>;
    /** The map of globals defined in the shader (attributes, shared variables, outputs ...), excluding uniforms */
    globals: Record<string, string>;
    /** Simple parsed #define constants. Only plain numbers and booleans are supported. */
    constDefs: Record<string, number | boolean>;
    infoLog: GlslInfoLogArray;
    minify: boolean;
    mangle: boolean;
    mangle_global_map: Record<string, string> | undefined;
    beautify: boolean;
    recordConstantPrecision: boolean;
    cwd: string | undefined;
    constructor();
}
export declare function spglslAngleCompile(input: Readonly<SpglslAngleCompileInput>): Promise<SpglslAngleCompileResult>;
export declare class SpglslAngleCompileError extends Error {
    code: "SPGLSL_ERR";
    spglslResult: SpglslAngleCompileResult;
    filePath: string;
    durationMs: number;
    get infoLog(): GlslInfoLogArray;
    constructor(spglslResult: SpglslAngleCompileResult, message?: string, caller?: Function);
}
export declare function inspectSpglslAngleCompileResult(result: SpglslAngleCompileResult): string;
