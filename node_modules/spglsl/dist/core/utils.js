"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prettySize = exports.utf8ByteLength = exports.makePathRelative = void 0;
const path_1 = require("path");
function makePathRelative(filePath, cwd) {
    if (!filePath) {
        return "./";
    }
    if (filePath.indexOf("\\") >= 0) {
        return filePath; // avoid doing this on windows
    }
    try {
        const relativePath = path_1.posix.normalize(path_1.posix.relative(cwd || process.cwd(), filePath));
        return relativePath && relativePath.length < filePath.length ? relativePath : filePath;
    }
    catch (_) {
        return filePath;
    }
}
exports.makePathRelative = makePathRelative;
function utf8ByteLength(b) {
    if (b === null || b === undefined) {
        return 0;
    }
    if (typeof b === "number") {
        return b || 0;
    }
    return typeof b === "string" ? Buffer.byteLength(b, "utf8") : b.length;
}
exports.utf8ByteLength = utf8ByteLength;
/** Gets a size in bytes in an human readable form. */
function prettySize(bytes, options) {
    if (bytes === null || bytes === undefined) {
        bytes = 0;
    }
    const appendBytes = !options || options.appendBytes === undefined || options.appendBytes;
    if (typeof bytes === "object" || typeof bytes === "string") {
        bytes = utf8ByteLength(bytes);
    }
    bytes = bytes < 0 ? Math.floor(bytes) : Math.ceil(bytes);
    let s;
    if (!isFinite(bytes) || bytes < 1024) {
        s = `${bytes} ${appendBytes ? "Bytes" : "B"}`;
    }
    else {
        const i = Math.min(Math.floor(Math.log(Math.abs(bytes)) / Math.log(1024)), 6);
        s = `${+(bytes / 1024 ** i).toFixed(2)} ${i ? " kMGTPE"[i] : ""}`;
        if (appendBytes) {
            s += `, ${bytes} Bytes`;
        }
    }
    if (options && options.fileType) {
        s = `${options.fileType} ${s}`;
    }
    return s;
}
exports.prettySize = prettySize;
//# sourceMappingURL=utils.js.map