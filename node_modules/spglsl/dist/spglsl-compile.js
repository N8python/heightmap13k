"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.inspectSpglslAngleCompileResult = exports.SpglslAngleCompileError = exports.spglslAngleCompile = exports.SpglslAngleCompileResult = void 0;
const chalk_1 = __importDefault(require("chalk"));
const glsl_info_log_1 = require("./glsl-info-log");
const _wasm_1 = require("./lib/_wasm");
const spglsl_enums_1 = require("./spglsl-enums");
const string_enums_1 = require("./core/string-enums");
const spglsl_resource_limits_1 = require("./spglsl-resource-limits");
const utils_1 = require("./core/utils");
const DEFAULT_RECORD_CONSTANT_PRECISION = false;
class SpglslAngleCompileResult {
    constructor() {
        this.source = "";
        this.compileMode = "Validate";
        this.language = "Fragment";
        this.mainFilePath = "";
        this.outputVersion = 300;
        this.valid = false;
        this.customData = undefined;
        this.output = null;
        this.uniforms = {};
        this.globals = {};
        this.constDefs = {};
        this.infoLog = new glsl_info_log_1.GlslInfoLogArray();
        this.minify = false;
        this.mangle = false;
        this.mangle_global_map = undefined;
        this.beautify = false;
        this.recordConstantPrecision = DEFAULT_RECORD_CONSTANT_PRECISION;
        this.duration = 0;
        this.cwd = undefined;
    }
}
exports.SpglslAngleCompileResult = SpglslAngleCompileResult;
async function spglslAngleCompile(input) {
    const startTime = process.hrtime();
    const result = new SpglslAngleCompileResult();
    result.compileMode = input.compileMode || spglsl_enums_1.SpglslCompileMode.Optimize;
    if (!string_enums_1.StringEnum.has(spglsl_enums_1.SpglslCompileMode, input.compileMode)) {
        throw new TypeError(`Invalid compile mode "${input.compileMode}"`);
    }
    result.customData = input.customData;
    result.minify = !!input.minify;
    result.mangle = input.mangle === undefined ? result.minify : !!input.mangle;
    result.mangle_global_map = input.mangle_global_map || undefined;
    result.beautify = input.beautify === undefined ? !result.minify : !!input.beautify;
    result.recordConstantPrecision = input.recordConstantPrecision || DEFAULT_RECORD_CONSTANT_PRECISION;
    result.cwd = input.cwd;
    const resourceLimits = { ...spglsl_resource_limits_1.SpglslResourceLimits, ...input.resourceLimits };
    const mainFilePath = input.mainFilePath || "0";
    result.mainFilePath = mainFilePath;
    let language;
    if (!input.language || input.language === "auto" || input.language === "AUTO" || input.language === "Auto") {
        language = (0, spglsl_enums_1.spglslLanguageFromString)(mainFilePath) || "Fragment";
    }
    else {
        language = (0, spglsl_enums_1.spglslLanguageFromString)(input.language) || input.language;
        if (!string_enums_1.StringEnum.has(spglsl_enums_1.SpglslLanguage, language)) {
            throw new TypeError(`Invalid language "${input.language}"`);
        }
    }
    result.language = language;
    if (input.mainSourceCode !== null && input.mainSourceCode !== undefined) {
        result.source = input.mainSourceCode;
    }
    const sourceCode = input.mainSourceCode || "";
    const constDefs = _parseConstDefs(sourceCode);
    const wasm = await (0, _wasm_1._wasmSpglslGet)();
    const wresult = wasm.spglsl.spglsl_angle_compile(result, resourceLimits, sourceCode) || {};
    result.infoLog.parseAdd(wresult.infoLog, mainFilePath, undefined, result.cwd);
    let valid = !!wresult.valid;
    if (valid && result.compileMode !== "Validate" && (wresult.output === null || wresult.output === undefined)) {
        valid = false;
    }
    const timeDiffiff = process.hrtime(startTime);
    result.duration = Math.ceil((timeDiffiff[0] * 1e9 + timeDiffiff[1]) * 1e-6);
    if (!valid && !result.infoLog.hasErrors()) {
        result.infoLog.push(new glsl_info_log_1.GlslInfoLogRow("ERROR", mainFilePath, 0, "", "compilation errors.", result.cwd));
        return result;
    }
    result.infoLog.removeDuplicates();
    result.valid = !result.infoLog.hasErrors();
    result.output = typeof wresult.output === "string" ? wresult.output : null;
    result.uniforms = wresult.uniforms || {};
    result.globals = wresult.globals || {};
    result.constDefs = constDefs;
    return result;
}
exports.spglslAngleCompile = spglslAngleCompile;
class SpglslAngleCompileError extends Error {
    get infoLog() {
        return this.spglslResult.infoLog;
    }

    constructor(spglslResult, message, caller) {
        super(message || `spglsls  ${spglslResult.compileMode || "compilation"} failed`);
        this.spglslResult = spglslResult;
        this.code = "SPGLSL_ERR";
        this.filePath = spglslResult.mainFilePath;
        this.durationMs = spglslResult.duration;
        if (spglslResult.infoLog.hasErrors()) {
            Reflect.defineProperty(this, "stack", {
                value: spglslResult.infoLog.inspect(),
                configurable: true,
                enumerable: true,
                writable: true,
            });
        }
        else if (caller) {
            Error.captureStackTrace(this, caller);
        }
        Reflect.defineProperty(this, "spglslResult", {
            value: spglslResult,
            configurable: true,
            enumerable: false,
            writable: true,
        });
    }
}
exports.SpglslAngleCompileError = SpglslAngleCompileError;
function inspectSpglslAngleCompileResult(result) {
    const infologCounts = result.infoLog.getCounts();
    const filePath = (result.mainFilePath && (0, utils_1.makePathRelative)(result.mainFilePath, result.cwd)) || result.mainFilePath || "glsl";
    let text;
    if (!result.valid) {
        text = chalk_1.default.redBright(`${filePath} errors `);
    }
    else {
        text = chalk_1.default.blueBright(`${filePath} `);
        if (infologCounts.warnings) {
            text += chalk_1.default.yellow("warnings");
        }
        else {
            text += chalk_1.default.greenBright("ok");
        }
        const sizeOriginal = (0, utils_1.prettySize)(result.source);
        if (sizeOriginal) {
            text += ` ${chalk_1.default.cyan(sizeOriginal)}`;
            if (result.compileMode !== "Validate" && typeof result.output === "string") {
                const sizeAfter = (0, utils_1.prettySize)(result.output);
                if (sizeAfter !== sizeOriginal) {
                    text += ` ${chalk_1.default.blueBright("->")} ${chalk_1.default.cyanBright(sizeAfter)}`;
                }
            }
        }
    }
    text += chalk_1.default.gray(`  ${result.duration} ms`);
    if (infologCounts.errors || infologCounts.warnings) {
        text += `\n${result.infoLog.inspect()}`;
    }
    return text;
}
exports.inspectSpglslAngleCompileResult = inspectSpglslAngleCompileResult;
function _parseConstDefs(source) {
    const defines = source.matchAll(/^\s*#\s*define\s*(\w+)\s+(.+)$/gm);
    const result = {};
    for (const def of defines) {
        if (def[1]) {
            const name = def[1];
            const value = def[2];
            if (value === "true") {
                result[name] = true;
            }
            else if (value === "false") {
                result[name] = false;
            }
            else if (value !== undefined) {
                const parsed = parseFloat(value);
                if (!isNaN(parsed)) {
                    result[name] = parsed;
                }
            }
        }
    }
    return result;
}
//# sourceMappingURL=spglsl-compile.js.map